# -*- coding: utf-8 -*-
"""METAR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16CKkTINmNW7TlkxX0smpaZWYQYPqFwB5
"""


from datetime import datetime
import metar.Metar as mt
import pandas as pd
import re

DEFAULT_YEAR = 2024
DEFAULT_MONTH = 10


def decode_metar_to_csv(input_file, output_file):
    try:
        with open(input_file, "r") as file:
            metar_text = file.read().strip()

        metar_reports = re.split(r'\nMETAR ', metar_text)
        data_list = []

        for metar_code in metar_reports:
            metar_code = metar_code.strip()
            if not metar_code:
                continue

            if not metar_code.startswith("METAR"):
                metar_code = "METAR " + metar_code

            nosig_present = "NOSIG" in metar_code
            metar_code = metar_code.replace("NOSIG", "")

            try:
                report = mt.Metar(metar_code, month=9)
                # Adjust the observation date safely
                # corrected_time = adjust_metar_date(report.time.day)
                # print("corrected_time = ", corrected_time)

                data = {
                    # "Station": getattr(report, "station", "Mumbai/Chhatrapati Shivaji Intl"),
                    # "Location": getattr(report, "name", "India 19.07N 072.51E"),
                    "DAY": report.time.strftime("%d"),
                    "TIME": f"{report.time.hour:02}{report.time.minute:02}Z",
                    # "Wind Speed (m/s)": report.wind_speed.value("MPS") if report.wind_speed else "N/A",
                    "WIND_DIR": report.wind_dir.value() if report.wind_dir else "N/A",
                    "WIND_SPEED": report.wind_speed.value("KT") if report.wind_speed else "N/A",
                    # "Visibility (m)": report.vis.value() if report.vis else "N/A",
                    # "Present Weather": report.present_weather() if report.present_weather() else "None",
                    # "Clouds": report.sky_conditions() if report.sky_conditions() else "No Significant Cloud",
                    "TEMP": report.temp.value("C") if report.temp else "N/A",
                    # "Dew-Point Temperature (°C)": report.dewpt.value("C") if report.dewpt else "N/A",
                    "QNH": report.press.value("hPa") if report.press else "N/A",
                    # "Significant Change": "No significant change" if nosig_present else metar_code.split()[-1],
                }

                data_list.append(data)

            except Exception as e:
                print(f"Error decoding METAR: {e}\nProblematic METAR: {metar_code}")

        df = pd.DataFrame(data_list)
        df.to_csv(output_file, index=False)
        # print(df)
        print(f"Decoded METAR data saved to {output_file}")
        return(df)
    except Exception as e:
        print(f"Error processing METAR file: {e}")

# # Example usage
# df1: pd.DataFrame | None = decode_metar_to_csv("METAR_OBS_092023.txt", "decoded_metar.csv")

# df1

# import pandas as pd

# # Load the raw text
# with open('TAKEOFF_Forecast_092023.txt', 'r') as f:
#     lines = f.readlines()

# # Preview a few lines to identify the header and data
# for i, line in enumerate(lines[:10]):
#     print(f"{i}: {line.strip()}")

# import re
# import pandas as pd

def extract_wind_data(wind_str):
    """
    Extracts wind direction and speed from a wind string, handling various formats.
    """
    # Format with slash and KT (e.g., "310/05KT")
    match = re.match(r'(\d{3})/(\d{2})KT', wind_str)
    if match:
        return int(match.group(1)), int(match.group(2))

    # Format with digits and KT (e.g., "35005KT")
    match = re.match(r'(\d{3})(\d{2})KT', wind_str)
    if match:
        return int(match.group(1)), int(match.group(2))

    # Format with gust and KT (e.g., "28007G17KT")
    match = re.match(r'(\d{3})\d{2}G(\d{2})KT', wind_str)
    if match:
        return int(match.group(1)), int(match.group(2))

    # Variable wind with KT (e.g., "VRB02KT")
    match_vrb_kt = re.match(r'(VRB)(\d{2})KT', wind_str)
    if match_vrb_kt:
        return "N/A", int(match_vrb_kt.group(2))

    # Variable wind without KT, but with speed (e.g., "VRB05")
    match_vrb_no_kt = re.match(r'(VRB)(\d{2})', wind_str)
    if match_vrb_no_kt:
        return "N/A", int(match_vrb_no_kt.group(2))

    # Variable wind with slash and KT (e.g., "VRB/02KT") - might exist in some formats
    match_vrb_slash_kt = re.match(r'(VRB)/(\d{2})KT', wind_str)
    if match_vrb_slash_kt:
        return "N/A", int(match_vrb_slash_kt.group(2))

    # Variable wind with slash and no KT (e.g., "VRB/02") - might exist
    match_vrb_slash_no_kt = re.match(r'(VRB)/(\d{2})', wind_str)
    if match_vrb_slash_no_kt:
        return "N/A", int(match_vrb_slash_no_kt.group(2))

    # Handle just "VRB" with no speed information
    if "VRB" == wind_str:
        return "N/A", None

    # New format with slash and no KT (e.g., "320/07") - Keep this for numeric directions
    match_numeric_slash = re.match(r'(\d{3})/(\d{2})', wind_str)
    if match_numeric_slash:
        return int(match_numeric_slash.group(1)), int(match_numeric_slash.group(2))

    return None, None  # Return None, None if no match


def extract_data_from_file_with_day_and_wind(file_path):
    """
    Extracts data from a file, including day, time, and separated wind direction/speed.

    Args:
        file_path (str): The path to the file.

    Returns:
        pandas.DataFrame: DataFrame with extracted data.
    """

    data = []
    day = 1
    try:
        with open(file_path, 'r') as file:
            next(file)
            for line in file:
                line = line.strip()
                if line:
                    if re.match(r'^\d+$', line) and len(line) <= 2:
                        day = int(line)
                        continue
                    match = re.match(
                        r'(\d{4}Z)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\d+)', line)
                    if match:
                        time, wind_str, temp, qfe, qnh = match.groups()
                        wind_dir, wind_speed = extract_wind_data(wind_str)
                        data.append({
                            'DAY': day,
                            'TIME': time,
                            'WIND_DIR': wind_dir,
                            'WIND_SPEED': wind_speed,
                            'TEMP': int(temp),
                            'QFE': int(qfe),
                            'QNH': int(qnh)
                        })
        return pd.DataFrame(data)
    except FileNotFoundError:
        print(f"Error: File not found at {file_path}")
        return pd.DataFrame()
    except Exception as e:
        print(f"An error occurred: {e}")
        return pd.DataFrame()


# # Example usage:
# file_path = 'TAKEOFF_Forecast_092023.txt'
# df2 = extract_data_from_file_with_day_and_wind(file_path)

# if not df2.empty:
#     print(df2)
# else:
#     print("No data extracted.")
# df2

# df2.isna().sum()

# import pandas as pd

def compare_wind_by_time(df1, df2):
    """
    Compares wind data from two DataFrames based on matching *first* 'TIME' values.
    Handles potential duplicates by keeping only the first occurrence of each time.

    Args:
        df1 (pd.DataFrame): Actual (METAR) data with 'TIME', 'WIND_DIR', 'WIND_SPEED'.
        df2 (pd.DataFrame): Forecast data with 'TIME', 'WIND_DIR', 'WIND_SPEED'.

    Returns:
        pd.DataFrame: Merged DataFrame with 'Accuracy' column.
    """

    if not isinstance(df1, pd.DataFrame) or not isinstance(df2, pd.DataFrame):
        print("Error: Input arguments must be Pandas DataFrames.")
        return pd.DataFrame()

    if 'TIME' not in df1.columns or 'TIME' not in df2.columns:
        print("Error: Both DataFrames must contain a 'TIME' column.")
        return pd.DataFrame()

    # Remove duplicate times, keeping the first occurrence
    df1_unique = df1.drop_duplicates(subset='TIME', keep='first')
    df2_unique = df2.drop_duplicates(subset='TIME', keep='first')

    merged_df = pd.merge(df1_unique, df2_unique, on='TIME', suffixes=('_actual', '_forecast'), how='inner')

    if merged_df.empty:
        print("No matching times found between the DataFrames.")
        return pd.DataFrame()

    accuracy = []
    # save the merged_df to a csv file
    merged_df.to_csv('merged_df.csv', index=False)
    for _, row in merged_df.iterrows():
        actual_dir = row['WIND_DIR_actual']
        actual_speed = row['WIND_SPEED_actual']
        forecast_dir = row['WIND_DIR_forecast']
        forecast_speed = row['WIND_SPEED_forecast']

        dir_accurate = False
        speed_accurate = False

        if actual_dir == 'VRB' or forecast_dir == 'VRB' or actual_dir is None or forecast_dir is None:
            dir_accurate = True
        else:
            try:
                dir_diff = abs(int(forecast_dir) - int(actual_dir))
                dir_accurate = dir_diff <= 30 or dir_diff >= 330
            except (ValueError, TypeError):
                print("Invalid wind direction: ", forecast_dir, actual_dir)

        if actual_speed is not None and forecast_speed is not None:
            try:
                speed_accurate = abs(int(forecast_speed) - int(actual_speed)) <= 1
            except (ValueError, TypeError):
                print("Invalid wind speed: ", forecast_speed, actual_speed)
        else:
            print(f"Warning: Missing wind speed for TIME {row['TIME']}.")

        accuracy.append('Accurate' if dir_accurate and speed_accurate else 'Not Accurate')

    merged_df['Accuracy'] = accuracy
    return merged_df

# comparison_df = compare_wind_by_time(df1, df2)
# print(comparison_df)

def circular_difference(dir1, dir2):
    """
    Calculates the minimum angular difference between two directions, considering circular wrap-around.
    """
    if dir1 is None or dir2 is None or not isinstance(dir1, (int, float)) or not isinstance(dir2, (int, float)):
        return None  # Or raise an exception, depending on your error handling

    return min(abs(dir1 - dir2), 360 - (abs(dir1 - dir2)))

def compare_weather_data(df1, df2, wind_dir_threshold=30, wind_speed_threshold=5, temp_threshold=1, qnh_threshold=1):
    """
    Compares weather data from two DataFrames based on matching 'DAY' and 'TIME'.

    Args:
        df1 (pd.DataFrame): Actual (METAR) data with 'TIME', 'WIND_DIR', 'WIND_SPEED', 'TEMP', 'QNH', and 'DAY'.
        df2 (pd.DataFrame): Forecast data with 'TIME', 'WIND_DIR', 'WIND_SPEED', 'TEMP', 'QNH', and 'DAY'.
        wind_dir_threshold (int): Threshold for wind direction accuracy in degrees.
        wind_speed_threshold (int): Threshold for wind speed accuracy in knots.
        temp_threshold (int): Threshold for temperature accuracy in °C.
        qnh_threshold (int): Threshold for QNH accuracy in hPa.

    Returns:
        pd.DataFrame: Merged DataFrame with 'Accuracy' column.
    """

    if not isinstance(df1, pd.DataFrame) or not isinstance(df2, pd.DataFrame):
        print("Error: Input arguments must be Pandas DataFrames.")
        return pd.DataFrame()

    required_columns = ['TIME', 'WIND_DIR', 'WIND_SPEED', 'TEMP', 'QNH', 'DAY']
    
    # Check if all required columns are in df1
    if not all(col in df1.columns for col in required_columns):
        missing_cols = [col for col in required_columns if col not in df1.columns]
        print(f"Error: METAR DataFrame is missing columns: {missing_cols}")
        return pd.DataFrame()
    
    # Check if all required columns except QNH are in df2
    forecast_required = ['TIME', 'WIND_DIR', 'WIND_SPEED', 'TEMP', 'DAY']
    if not all(col in df2.columns for col in forecast_required):
        missing_cols = [col for col in forecast_required if col not in df2.columns]
        print(f"Error: Forecast DataFrame is missing columns: {missing_cols}")
        return pd.DataFrame()
    
    # If QNH is not in df2 but QFE is, use QFE as QNH
    if 'QNH' not in df2.columns and 'QFE' in df2.columns:
        df2['QNH'] = df2['QFE']
    elif 'QNH' not in df2.columns:
        print("Error: Forecast DataFrame is missing QNH column and no QFE column to substitute.")
        return pd.DataFrame()

    # Combine DAY and TIME for unique identification
    df1['DATETIME'] = df1['DAY'].astype(str).str.zfill(2) + ' ' + df1['TIME'].astype(str)
    df2['DATETIME'] = df2['DAY'].astype(str).str.zfill(2) + ' ' + df2['TIME'].astype(str)

    # Remove duplicate date-times, keeping the first occurrence
    df1_unique = df1.drop_duplicates(subset='DATETIME', keep='first')
    df2_unique = df2.drop_duplicates(subset='DATETIME', keep='first')

    merged_df = pd.merge(df1_unique, df2_unique, on='DATETIME', suffixes=('_actual', '_forecast'), how='inner')

    if merged_df.empty:
        print("No matching day and times found between the DataFrames.")
        return pd.DataFrame()

    accuracy = []
    for _, row in merged_df.iterrows():
        actual_dir = row['WIND_DIR_actual']
        forecast_dir = row['WIND_DIR_forecast']
        actual_speed = row['WIND_SPEED_actual']
        forecast_speed = row['WIND_SPEED_forecast']
        actual_temp = row['TEMP_actual']
        forecast_temp = row['TEMP_forecast']
        actual_qnh = row['QNH_actual']
        forecast_qnh = row['QNH_forecast']

        dir_accurate = False
        speed_accurate = False
        temp_accurate = False
        qnh_accurate = False

        # Handle direction accuracy
        if actual_dir == 'VRB' or forecast_dir == 'VRB' or actual_dir == 'N/A' or forecast_dir == 'N/A' or pd.isna(actual_dir) or pd.isna(forecast_dir):
            dir_accurate = True
        else:
            try:
                dir_diff = circular_difference(int(forecast_dir), int(actual_dir))
                dir_accurate = dir_diff is not None and dir_diff <= wind_dir_threshold
            except (ValueError, TypeError):
                print(f"Warning: Invalid wind direction for DATETIME {row['DATETIME']}.")

        # Handle speed accuracy
        if pd.notna(actual_speed) and pd.notna(forecast_speed) and actual_speed != 'N/A' and forecast_speed != 'N/A':
            try:
                speed_accurate = abs(int(forecast_speed) - int(actual_speed)) <= wind_speed_threshold
            except (ValueError, TypeError):
                print(f"Warning: Invalid wind speed for DATETIME {row['DATETIME']}.")
        else:
            print(f"Warning: Missing wind speed for DATETIME {row['DATETIME']}.")

        # Handle temperature accuracy
        if pd.notna(actual_temp) and pd.notna(forecast_temp) and actual_temp != 'N/A' and forecast_temp != 'N/A':
            try:
                temp_diff = abs(float(forecast_temp) - float(actual_temp))
                temp_accurate = temp_diff <= temp_threshold
            except (ValueError, TypeError):
                print(f"Warning: Invalid temperature for DATETIME {row['DATETIME']}.")
        else:
            print(f"Warning: Missing temperature for DATETIME {row['DATETIME']}.")

        # Handle QNH accuracy
        if pd.notna(actual_qnh) and pd.notna(forecast_qnh) and actual_qnh != 'N/A' and forecast_qnh != 'N/A':
            try:
                qnh_diff = abs(float(forecast_qnh) - float(actual_qnh))
                qnh_accurate = qnh_diff <= qnh_threshold
            except (ValueError, TypeError):
                print(f"Warning: Invalid QNH for DATETIME {row['DATETIME']}.")
        else:
            print(f"Warning: Missing QNH for DATETIME {row['DATETIME']}.")

        # Final result
        accuracy.append('Accurate' if all([dir_accurate, speed_accurate, temp_accurate, qnh_accurate]) else 'Not Accurate')

    merged_df['Accuracy'] = accuracy
    return merged_df

# comparison_df = compare_weather_data(df1, df2)
# print(comparison_df)

# # Filter rows where accuracy is exactly 'accurate'
# accurate_rows = comparison_df[comparison_df['Accuracy'] == 'Accurate']

# # Print the accurate rows
# print(accurate_rows)